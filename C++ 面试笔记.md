- #### malloc 和new 都用于动态内存分配，区别在于：

  1. **来源和使用**：`new/delete`是C++的操作符，需要编译器支持；而`malloc/free`是库函数，需要引入相应的头文件才可以正常使用。

  2. **使用方式**：`malloc`需要显式填入申请内存的大小；而`new`无需显式填入申请的内存大小，`new`会根据类型自动分配内存。

  3. **返回类型**：`new`操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故`new`是符合类型安全性的操作符。而`malloc`内存分配成功则是返回`void *，需要通过强制类型转换将`void*`指针转换成我们需要的类型。

  4. **分配失败情况**：`malloc`分配内存失败时返回NULL；`new`内存分配失败时，会抛出`bac_alloc`异常。

  5. **定义对象系统调度过程**：使用`new`操作符来分配对象内存时会经历三个步骤：调用`operator new`函数分配内存空间，运行相应的构造函数以构造对象，对象构造完成后，返回一个指向该对象的指针¹²。

  6. **是否可以被重载**：`operator new` / `operator delete`可以被重载²。

  7. **配对使用**：`new/delete`，`malloc/free`必须配对使用⁴⁵。如果用`free`释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用`delete`释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。

  

- ####           **STL容器是线程安全的吗**？

  1. **线程安全**是指当多个线程同时访问某个共享资源时，不会出现不可预期的结果或者数据损坏的情况。在并发编程中，线程安全非常重要，因为多个线程同时对同一资源进行读写可能导致数据不一致或者损坏。
  2. **STL的容器（例如vector、list、map等）和算法（例如sort、find等）通常不是线程安全的**。这意味着如果多个线程同时操作同一个STL容器或者调用同一个STL算法，可能会导致不可预期的结果，例如数据损坏、死锁等问题。
  3. 要在多线程环境下安全地使用STL，你需要使用适当的同步机制（例如**互斥锁、读写锁、原子操作**，例如`std::shared_mutex`、`std::atomic`、或者一些基于锁的线程安全容器（例如`std::mutex`和`std::lock_guard`等）来保证线程安全），以及避免数据竞争和死锁的发生。



- ####           dynamic_cast 和static_cast的区别？

​	***`dynamic_cast`在运行时检查转换的安全性，而`static_cast`在编译时执行转换，不检查转换的安全性。因此，在处理多态时，应优先考虑使用`dynamic_cast`。在处理非多态类型转换或内置数据类型转换时，可以使用`static_cast`***

1. **`static_cast`：**

   - 在编译时进行类型转换，不进行运行时的类型检查。
   - 主要用于类层次结构中的向上转换（派生类向基类）或者无关类型之间的转换，如整数之间的转换。
   - 可以将指针或引用转换为另一种指针或引用类型，但需要保证转换是安全的，否则可能导致未定义行为。
   - 通常不能用于多态类型的向下转换，因为它不进行运行时的类型检查。

2. **`dynamic_cast`：**

   - `dynamic_cast`主要用于处理**多态**。它在运行时检查转换的有效性，以便进行**安全的向下转换（如基类的指针/引用指向的是派生类对象，此时可以将基类转换为派生类**）和向上转换。

   - 如果转换是合法的，即源指针指向的对象是目标类型的一个子类对象，那么转换成功并返回目标类型的指针或引用；**否则，返回空指针（对指针进行转换）或抛出`std::bad_cast`异常（对引用进行转换**）。

     



- #### **什么是多态，虚函数表和虚函数指针是对象拥有还是类拥有？**

​	**多态**允许不同类型的对象对同一个接口作出不同的响应。在C++中，多态主要通过虚函数和继承来实现。分为静态多态（编译时多态）和动态多态（运行时多态）两种形式：

1. **静态多态（编译时多态）**：静态多态是在编译时实现的，主要通过函数重载和模板（包括模板函数和模板类）来实现。编译器在编译时根据参数的静态类型来决定调用哪个函数，或者实例化哪个模板。
2. **动态多态（运行时多态）**：动态多态是在运行时实现的，主要通过虚函数和继承来实现。在基类中声明虚函数，派生类可以重写（override）基类定义的虚函数，在使用基类指针或引用调用虚函数时，会根据对象的实际类型调用相应的函数实现，而不是根据指针或引用的静态类型

​	当你在一个类中声明一个虚函数时，**编译器会为这个类创建一个虚函数表。（虚函数表是一个存储类的虚函数地址的表），为每个类的对象添加一个虚函数指针**。这个指针指向该类的虚函数表。当你通过基类的指针或引用调用虚函数时，编译器会使用这个虚函数指针来查找正确的函数版本。



- #### **当一个类声明了虚函数，编译器会如何建立虚函数表的**

  1. **创建虚函数表**：当编译器发现一个类声明了虚函数，它会为这个类创建一个虚函数表。虚函数表中的每一项都是一个函数指针，指向该类的一个虚函数。

  2. **填充虚函数表**：编译器会扫描这个类的所有成员函数，如果发现一个函数被声明为虚函数，就会将这个函数的地址添加到虚函数表中。如果这个类继承自其他类，并且重写了基类的虚函数，那么编译器会用派生类的函数地址替换虚函数表中对应的项。

  3. **添加虚函数指针**：编译器会在每个类的对象中添加一个虚函数指针。这个指针指向该类的虚函数表。当创建一个对象时，编译器会自动将这个虚函数指针初始化为指向该类的虚函数表。

     ![image-20240518223637179](./图片/image-20240518223637179.png)





- #### **析构函数一般写成虚函数的原因**

  ​		当基类指针指向派生类对象，并使用该指针调用析构函数时（**多态析构**），如果**析构函数不是虚函数**，那么只会调用基类的析构函数，而不会调用派生类的析构函数。这样可能**导致在派生类中申请的资源没有被正确释放，造成内存泄漏或其他问题**。通过**将析构函数声明为虚函数**，可以确保在使用基类指针释放派生类对象时，**会调用正确的析构函数，从而正确释放资源**。

  

- #### **构造函数不可以写成虚函数的原因**

  ***编译器不允许构造函数写成虚函数**，*

  1. 从存储空间角度：在对象的构造过程中，虚函数表和虚函数指针尚未建立，因此无法进行动态绑定。如果构造函数是虚函数，那么在构造对象时，无法使用虚函数的机制来实现多态性。

  2. 从使用角度：虚函数的作用在于通过父类的指针或者引用来调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数。

     

- #### **为什么不建议析构和构造函数使用虚函数，是编译期间出错还是运行期间出错**

  **在C++中，构造函数和析构函数内部调用虚函数是可以的，编译器不会报错**。但是，可能会导致在运行期间出现**不确定的行为或错误，而不是在编译期间出现错误**。原因如下：

  1. **在构造函数中调用虚函数**：由于类的构造顺序是先构造基类然后再构造派生类，所以在构造函数中调用虚函数，虚函数是不会呈现出多态的。也就是说，如果**在基类的构造函数中调用了虚函数，那么此时调用的将是基类自身的虚函数版本，而不是派生类中重写的版本。**

  2. **在析构函数中调用虚函数**：类的析构顺序是先析构派生类然后再析构基类，所以**当调用派生类的析构函数时，这代表其派生类已经进行了析构，所以也并不会呈现多态**。也就是说，如果在基类的析构函数中调用了虚函数，那么此时调用的将是基类自身的虚函数版本，而不是派生类中重写的版本。

     但是**如果在基类中声明*纯虚函数*并且在基类的析构函数中调用，编译器会报错。**

     纯虚函数是一个没有实现的虚函数，它的存在是为了让派生类必须提供自己的实现。**但是在基类析构函数中调用纯虚函数时，基类并不知道派生类是否提供了实现，也无法调用派生类的实现。因此，编译器会认为这是一个错误**，因为在基类析构函数中调用纯虚函数可能会导致不确定的行为或程序错误。

  

- #### 什么是纯虚函数

  纯虚函数是C++中的一个特殊概念，它**在基类中被声明，但并没有在基类中定义**。**纯虚函数的主要目的是要求任何派生类都必须定义自己的实现方法**。以下是纯虚函数的一些主要特点：

  1. **定义**：纯虚函数在基类中的声明形式是在函数原型后**加`=0`**，例如：`virtual void func() = 0;`
  2. **抽象类**：包含纯虚函数的类被称为抽象类，**抽象类不能生成对象**，只能被继承。**如果派生类没有重新定义基类的纯虚函数，那么这个派生类仍然还是一个抽象类**。
  3. **实现**：实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
  6. **注意事项**：无论虚函数还是纯虚函数，定义中都不能有 `static` 关键字。




- #### **c++内存管理机制**

1. **内存模型**：C++的内存模型主要分为五个部分：
    - **栈（Stack）**：栈区由编译器自动分配和释放，用来存放函数的局部变量、函数的参数值等。
    - **堆（Heap）**：堆是通过`new`，`malloc`等函数分配的内存块，需要程序员手动控制其释放。
    - **全局/静态存储区（Global/Static Storage Area）**：存放全局变量和静态变量，程序结束后由系统释放。
    - **常量存储区**：存放常量，不允许修改。
    - **代码区**：存放函数体的二进制代码。

2. **内存分配**：C++提供了多种内存分配方式，包括静态内存分配和动态内存分配¹²⁴⁵：
    - **静态内存分配**：在程序编译时就已经分配好内存，运行时不能改变分配的内存大小，程序执行速度快，但是空间利用率低，不能灵活分配内存空间。
    - **动态内存分配**：在程序运行时才分配内存，可以根据需要灵活地分配和释放内存空间。

3. **内存泄漏**：内存泄漏是指程序在动态分配内存后，未释放或者未能完全释放该内存空间的情况。这样会导致内存不断被占用，进而导致程序性能下降、甚至崩溃等问题。

4. **内存对齐**：对于基础类型，如`float`, `double`, `int`, `char`等，它们的大小和内存占用是一致的。而对于结构体而言，如果我们取得其`sizeof`的结果，会发现这个值有可能会大于结构体内所有成员大小的总和，这是由于结构体内部成员进行了内存对齐。

5. **内存碎片**：程序的内存往往不是紧凑连续排布的，而是存在着许多碎片。我们根据碎片产生的原因把碎片分为内部碎片和外部碎片两种类型。

6. **内存控制**：在C++中，可以通过重载`new`和`delete`运算符来控制内存分配。





- #### **重载、重写和重定义的定义和区别：**

在C++中，**重载**、**重写**和**重定义**是三种不同的函数行为：

1. **重载（Overloading）**：重载发生在**同一个类中，函数名相同，但参数列表不同**。重载只是在类的内部存在。

2. **重写（Override）**：重写，也称为覆盖，发生在**两个类（基类和派生类）之间**。派生类**重新定义了基类中有相同名称和参数的虚函数。函数特征相同，但具体实现不同**，主要是在继承关系中出现的。

3. **重定义（Redefining）**：**重定义，也称为隐藏，是指派生类的函数屏蔽了与其同名的基类函数。**如果派生类的函数和基类的**函数同名，但参数不同，此时，不管有无virtual，基类的函数被隐藏**。如果派生类的函数与基类的**函数同名，并且参数也相同，但基类函数没有virtual关键字，此时，基类的函数被隐藏。**



- #### **什么情况下会调用拷贝构造函数(三种情况）**

  1. ⼀个对象**以值传递的⽅式传⼊函数体**，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中。 
  2. ⼀个对象**以值传递的⽅式从函数返回**，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值。
  3.  ⼀个对象需要通过另外⼀个对象进⾏初始化。



- #### **深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）**

1. **浅拷贝**：浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。

2. **深拷贝**：深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。

​		当⼀个对象需要通过另外⼀个对象进⾏初始化，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。 但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指ᰀ指针的问题。 所以，这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从 ⽽也就解决来ᰀ指针的问题。简⽽⾔之，当数据成员中有指针时，必需要⽤深拷⻉更加安全



- #### **指针和引用的区别**

在C++中，**指针**和**引用**都可以用来间接访问另一个值，但它们有一些重要的区别¹²³⁴：

1. **定义和性质**：指针是一个变量，存储的是一个地址，指向内存的一个存储单元；引用是原变量的一个别名，跟原来的变量实质上是同一个东西。

2. **多级指针和引用**：指针可以有多级，例如`int **p;`，而引用只能是一级。

3. **初始化**：指针可以在定义的时候不初始化，例如`int *p;`，而引用必须在定义的时候初始化，例如`int a = 996; int &r = a;`。

4. **NULL值**：指针可以指向NULL，例如`int *p = NULL;`，而引用不可以为NULL。

5. **改变指向**：指针初始化之后可以再改变，例如`int a = 996; int *p = &a; int b = 885; p = &b;`，而引用一旦被初始化，就不能再改变。

6. **sizeof运算结果**：`sizeof`一个指针得到的是指针本身的大小，而`sizeof`一个引用得到的是所引用的变量的大小。

7. **自增运算**：指针和引用的自增运算意义不同，例如`int a = 996; int *p = &a; int &r = a; p++; r++;`，`p++`之后指向`a`后面的内存，`r++`相当于`a++`。

总的来说，指针和引用都是地址的概念，但是指针是一个实体，可以改变指向的对象，而引用是一个别名，只能在定义时被初始化一次，不能改变引用的对象。





- #### **什么是乐观锁和悲观锁**

1. **悲观锁**：
   - 悲观锁的基本思想是在访问共享资源之前，先假设其他线程会对资源进行修改，因此会对资源进行加锁以确保数据的一致性。
   - 当一个线程获取到悲观锁后，其他线程需要等待锁释放才能访问相应的资源。
   - 典型的悲观锁如互斥锁（mutex）和读写锁（read-write lock）。

2. **乐观锁**：
   - 乐观锁的基本思想是假设在大多数情况下，资源不会发生冲突，因此不立即加锁，而是在更新资源时检查是否被其他线程修改过。
   - 如果没有被修改，更新可以顺利完成；如果被修改，可以采取一些策略，如重试或者回滚。
   - 乐观锁通常使用比较并交换（Compare-and-Swap，CAS）等原子操作来实现。
   - 乐观锁不会阻塞其他线程，因此适用于读操作频繁、写操作较少的场景，可以提高并发性能。
   - 无锁编程也可以被看作是乐观锁的一种，其中不使用显式的锁来实现并发控制。

一些常见的乐观锁和悲观锁的实现包括：

- **乐观锁**：版本号控制（Versioning）、CAS 操作、无锁数据结构（如无锁队列、无锁哈希表等）。
- **悲观锁**：互斥锁（Mutex）、读写锁（Read-Write Lock）、信号量（Semaphore）等。

在实际应用中，选择乐观锁还是悲观锁取决于具体的场景和性能需求。通常来说，悲观锁适用于写操作频繁的场景，而乐观锁适用于读操作频繁的场景。





- #### STL中vector和list的区别

在C++的STL库中，`vector`和`list`是两种常用的容器，它们的主要区别在于底层数据结构和操作性能：

1. **底层数据结构**：
    - `vector`的底层实现是动态顺序表，内存空间是连续的。
    - `list`的底层实现是双向链表，内存空间是不连续的。

2. **操作性能**：
    - `vector`支持高效的随机访问，时间复杂度为O(1)，但插入和删除操作会导致内存块的拷贝，时间复杂度为O(n)²。
    - `list`的随机访问效率较低，时间复杂度为O(n)，但由于链表的特点，能高效地进行插入和删除。

3. **迭代器失效**：
    - `vector`在插入元素时，可能会导致扩容，使原来的迭代器失效，删除元素时当前迭代器需要重新赋值，否则会失效。
    - `list`在插入元素的时候不会导致迭代器失效，删除元素的时候只会导致当前迭代器失效，其他的迭代器不会受到影响。

4. **使用场景**：
    - 如果需要高效的随机存取，而不在乎插入和删除的效率，使用`vector`。
    - 如果需要大量的插入和删除，而不关心随机存取，则应使用`list`。







- #### **TCP三次握手，为什么不能是两次*

- #### 缓存数据一致性用什么策略保证的？



**n个无序数组找出前K个值**



