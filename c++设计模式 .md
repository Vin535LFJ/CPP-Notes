# **c++设计模式**

## 设计原则：

1. **单一职责原则****：一个类应该只有一个引起变化的原因**，即一个类应该只负责一种职责。

   例如，考虑一个文件处理类，它既负责文件的读取又负责文件的写入。根据单一职责原则，可以将文件读取和文件写入分别放在两个类中，使得每个类只负责一种职责。

2. **开放封闭原则：**软件实体（类、模块、函数等）应该**对扩展开放，对修改关闭**。也就是说，当需要添加新功能时，应该尽量通过扩展已有代码来实现，而不是修改已有代码。

   例如，考虑一个图形绘制系统，其中有多种图形（圆形、矩形等）。如果要添加新的图形，可以通过创建新的子类来实现，而不需要修改已有的绘制代码。

3. **依赖倒转原则：高层模块不应该依赖低层模块，两个都应该依赖抽象；抽象不应该依赖细节，细节应该依赖抽象**。

​	**高层模块**：可以理解为上层应用，就是业务层的实现
​	**低层模块：**可以理解为底层接口，比如封装好的API、动态库等
​	**抽象**：指的就是抽象类或者接口，在C++中没有接口，只有抽象类



<img src="./图片/image-20240609213929692.png" alt="image-20240609213929692" style="zoom:67%;" />

4. **里氏代换原则**就是子类类型必须能够替换掉它们的父类类型。

5. **接口隔离原则（Interface Segregation Principle，ISP）**：客户端不应该依赖于它不需要使用的接口。接口应该**小而完备**。（即接口应该尽量不使用public，**如果是子类要使用应该设为protected,如果只是本类使用应该设成private**）

6. **合成复用原则**：尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。









## 组件协作类：

### 1）模板方法模式（Template Method）

**模板方法模式**是一种行为设计模式， 它在超类中定义了一个算法的**框架（稳定）**， 而将一些**步骤延迟（变化）到子类中**。允许子类在**不修改（复用）**结构的情况下重写该算法的某些特定步骤。

![image-20240610180016188](./图片/image-20240610180016188.png)

- *抽象步骤*必须由各个子类来实现
- *可选步骤*已有一些默认实现， 但仍可在需要时进行重写

还有另一种名为*钩子*的步骤。 *钩子*是内容为空的可选步骤。 即使不重写钩子， 模板方法也能工作。 钩子通常放置在算法重要步骤的前后， 为子类提供额外的算法扩展点。

![image-20240610180212149](./图片/image-20240610180212149.png)

![image-20240610180603673](./图片/image-20240610180603673.png)

**当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。**

 模板方法**将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展**， 同时还可让超类中所定义的结构保持完整。

 **当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。**

 在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。





### 2）策略模式（Strategy）

**策略模式**是一种行为设计模式， 它能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。该模式使得算法可以独立于使用它的客户程序（稳定）而变化（拓展，子类化）。

![image-20240610165112580](./图片/image-20240610165112580.png)

在导游(Navigator)应用中， 每个路线规划算法都可被抽取到只有一个 `build­Route`生成路线方法的独立类中。 该方法接收起点和终点作为参数， 并返回路线中途点的集合。

即使传递给每个路径规划类的参数一模一样， 其所创建的路线也可能完全不同。 主要导游类的主要工作是在地图上渲染一系列中途点， 不会在意如何选择算法。 该类中还有一个用于切换当前路径规划策略的方法， 因此客户端 （例如用户界面中的按钮） 可用其他策略替换当前选择的路径规划行为。

![image-20240610172609338](./图片/image-20240610172609338.png)

**当你想使用对象中各种不同的算法变体****，** **并希望能在运行时切换算法时****，** **可使用策略模式****。**

**当你有许多仅在执行某些行为时略有不同的相似类时****，** **可使用策略模式****。**

**如果算法在上下文的逻辑中不是特别重要****，** **使用该模式能将类的业务逻辑与其算法实现细节隔离开来****。**

**当类中使用了复杂条件运算符以在同一算法的不同变体中切换时****，** **可使用该模式****。**





### 3）观察者模式（Event-Subscriber、Observer）

**观察者模式**是一种行为设计模式， 允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

拥有一些值得关注的状态的对象通常被称为*目标*， 由于它要将自身的状态改变通知给其他对象， 我们也将其称为*发布者* （publisher）。 所有希望关注发布者状态变化的其他对象被称为*订阅者* （subscribers）。

观察者模式建议你为发布者类添加订阅机制， 让每个对象都能订阅或取消订阅发布者事件流。 不要害怕！ 这并不像听上去那么复杂。 实际上， 该机制包括 1） 一个用于存储订阅者对象引用的列表成员变量； 2） 几个用于添加或删除该列表中订阅者的公有方法。

![image-20240610184359759](./图片/image-20240610184359759.png)

![image-20240610184703691](./图片/image-20240610184703691.png)

![image-20240610194335928](./图片/image-20240610194335928.png)







## **单一职责类型：**

### 4）装饰模式（Decorator）

**装饰模式**是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

*封装器*是装饰模式的别称， 这个称谓明确地表达了该模式的主要思想。  **“封装器” 是一个能与其他 “目标” 对象连接的对象**。 封装器包含与目标对象相同的一系列方法， 它会将所有接收到的请求委派给目标对象。 但是， 封装器可以在将请求委派给目标前后对其进行处理， 所以可能会改变最终结果。

那么什么时候一个简单的封装器可以被称为是真正的装饰呢？ 正如之前提到的， 封装器实现了与其封装对象相同的接口。 因此从客户端的角度来看， 这些对象是完全一样的。 封装器中的引用成员变量可以是遵循相同接口的任意对象。 这使得你可以将一个对象放入多个封装器中， 并在对象中添加所有这些封装器的组合行为。

![image-20240610224426844](./图片/image-20240610224426844.png)



![image-20240610222105133](./图片/image-20240610222105133.png)

![image-20240610233728923](./图片/image-20240610233728923.png)

**如果你希望在无需修改代码的情况下即可使用对象****，** **且希望在运行时为对象新增额外的行为****，** **可以使用装饰模式****。

**如果用继承来扩展对象行为的方案难以实现或者根本不可行****，** **你可以使用该模式****。





### 5）桥模式（Bridge）

**桥接模式**是一种结构型设计模式， 可将一个大类或一系列紧密相关的类拆分为抽象和实现两个独立的层次结构， 从而能在开发时分别使用。***抽象部分* （也被称为*接口*） 是一些实体的高阶控制层**。 该层自身不完成任何具体的工作， 它需要将工作委派给***实现部分*层 （也被称为*平台*）**。注意， 这里提到的内容与编程语言中的*接口*或*抽象类*无关。 它们并不是一回事。在实际的程序中， 抽象部分是图形用户界面 （GUI）， 而实现部分则是底层操作系统代码 （API）， GUI 层调用 API 层来对用户的各种操作做出响应。

<img src="./图片/image-20240609233015579.png" alt="image-20240609233015579" style="zoom:67%;" />

桥接模式**通过将继承改为组合的方式**， 具体来说， 就是抽取其中一个维度并使之成为独立的类层次， 这样就可以在**初始类中引用这个新层次的对象**， 从而使得一个类不必拥有所有的状态和行为。

![image-20240609232850184](./图片/image-20240609232850184.png)

根据该方法， 我们可以**将颜色相关的代码抽取到拥有 `红色`和 `蓝色`两个子类的颜色类中， 然后在 `形状`类中添加一个指向某一颜色对象的引用成员变量**。 现在， 形状类可以将所有与颜色相关的工作委派给连入的颜色对象。 这样的**引用就成为了 `形状`和 `颜色`之间的桥梁**。 

![image-20240610161245043](./图片/image-20240610161245043.png)



![image-20240610163849875](./图片/image-20240610163849875.png)

**如果你想要拆分或重组一个具有多重功能的庞杂类（例如能与多个数据库服务器进行交互的类)， 可以使用桥接模式。**

 **如果你希望在几个独立维度上扩展一个类， 可使用该模式。**



